{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar React = require('react');\nvar utils = require('./utils.js');\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nconst ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nconst useClearResetErrorBoundary = errorResetBoundary => {\n  React__namespace.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nconst getHasError = _ref => {\n  let {\n    result,\n    errorResetBoundary,\n    useErrorBoundary,\n    query\n  } = _ref;\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && utils.shouldThrowError(useErrorBoundary, [result.error, query]);\n};\nexports.ensurePreventErrorBoundaryRetry = ensurePreventErrorBoundaryRetry;\nexports.getHasError = getHasError;\nexports.useClearResetErrorBoundary = useClearResetErrorBoundary;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;MAWaA,+BAA+B,GAAG,CAO7CC,OAP6C,EAc7CC,kBAd6C,KAe1C;EACH,IAAID,OAAO,CAACE,QAAR,IAAoBF,OAAO,CAACG,gBAAhC,EAAkD;IAChD;IACA,IAAI,CAACF,kBAAkB,CAACG,OAAnB,EAAL,EAAmC;MACjCJ,OAAO,CAACK,YAAR,GAAuB,KAAvB;IACD;EACF;AACF;AAEYC,gCAA0B,GACrCL,kBADwC,IAErC;EACHM,gBAAK,CAACC,SAAN,CAAgB,MAAM;IACpBP,kBAAkB,CAACQ,UAAnB;GADF,EAEG,CAACR,kBAAD,CAFH;AAGD;AAEM,MAAMS,WAAW,GAAG,QAqBrB;EAAA,IAfJ;IACAC,MADA;IAEAV,kBAFA;IAGAE,gBAHA;IAIAS;EAJA,CANyB;EAsBzB,OACED,MAAM,CAACE,OAAP,IACA,CAACZ,kBAAkB,CAACG,OAAnB,EADD,IAEA,CAACO,MAAM,CAACG,UAFR,IAGAC,sBAAgB,CAACZ,gBAAD,EAAmB,CAACQ,MAAM,CAACK,KAAR,EAAeJ,KAAf,CAAnB,CAJlB;AAMD","names":["ensurePreventErrorBoundaryRetry","options","errorResetBoundary","suspense","useErrorBoundary","isReset","retryOnMount","useClearResetErrorBoundary","React","useEffect","clearReset","getHasError","result","query","isError","isFetching","shouldThrowError","error"],"sources":["/Users/utkukoca/Desktop/Project-Challange/my-project/node_modules/@tanstack/react-query/src/errorBoundaryUtils.ts"],"sourcesContent":["import type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  UseErrorBoundary,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  useErrorBoundary: UseErrorBoundary<\n    TQueryFnData,\n    TError,\n    TQueryData,\n    TQueryKey\n  >\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(useErrorBoundary, [result.error, query])\n  )\n}\n"]},"metadata":{},"sourceType":"script"}