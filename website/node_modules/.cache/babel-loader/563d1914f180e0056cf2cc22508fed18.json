{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useSignTypedData = void 0;\nconst react_1 = require(\"react\");\nconst providers_1 = require(\"../providers\");\nfunction starknetSignReducer(state, action) {\n  if (action.type === 'start_signing') {\n    return {\n      ...state,\n      loading: true\n    };\n  } else if (action.type === 'set_signature') {\n    return {\n      ...state,\n      data: action.data,\n      loading: false\n    };\n  } else if (action.type === 'set_error') {\n    return {\n      ...state,\n      error: action.error,\n      loading: false\n    };\n  } else if (action.type === 'reset') {\n    return {\n      ...state,\n      data: undefined,\n      error: undefined,\n      loading: false\n    };\n  }\n  return state;\n}\n/**\n * Hook to sign typed data.\n *\n * @remarks\n *\n * This hook signs a JSON object for off-chain use with the current\n * wallet private key.\n *\n * @example\n * This example shows how to sign some data.\n * ```tsx\n * function Component() {\n *   const { data, signTypedData } = useSignTypedData(message)\n *   const message = {\n *     types: {\n *       Person: [\n *         { name: 'name', type: 'felt' }\n *       ],\n *       Mail: [\n *         { name: 'from', type: 'Person' }\n *       ]\n *     },\n *     primaryType: 'Mail',\n *     domain: {\n *       name: 'StarkNet Mail',\n *       version: '1',\n *       chainId: 1,\n *     },\n *     message: {\n *       from: {\n *         name: 'Alice'\n *       }\n *     }\n *   }\n *\n *   return (\n *     <>\n *       <p>\n *         <button onClick={signTypedData}>Sign</button>\n *       </p>\n *       {data && <p>Signed: {JSON.stringify(data)}</p>}\n *     </>\n *   )\n * }\n * ```\n */\nfunction useSignTypedData(typedData) {\n  const [state, dispatch] = (0, react_1.useReducer)(starknetSignReducer, {\n    loading: false\n  });\n  const {\n    account: accountAddress,\n    connectors\n  } = (0, providers_1.useStarknet)();\n  const reset = (0, react_1.useCallback)(() => {\n    dispatch({\n      type: 'reset'\n    });\n  }, [dispatch]);\n  const {\n    data,\n    error,\n    loading\n  } = state;\n  const signTypedData = (0, react_1.useCallback)(async () => {\n    dispatch({\n      type: 'reset'\n    });\n    dispatch({\n      type: 'start_signing'\n    });\n    try {\n      let accountInterface = null;\n      const availableConnectors = connectors.filter(conn => conn.available());\n      for (const connector of availableConnectors) {\n        const account = await connector.account();\n        if (account && account.address === accountAddress) {\n          accountInterface = account;\n          break;\n        }\n      }\n      if (!accountInterface) {\n        throw new Error(`No connector for address ${accountAddress}`);\n      }\n      const response = await accountInterface.signMessage(typedData);\n      dispatch({\n        type: 'set_signature',\n        data: response\n      });\n      return response;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err);\n      dispatch({\n        type: 'set_error',\n        error: errorMessage\n      });\n      console.error(err);\n    }\n  }, [accountAddress, connectors, typedData]);\n  return {\n    data,\n    error,\n    loading,\n    signTypedData,\n    reset\n  };\n}\nexports.useSignTypedData = useSignTypedData;","map":{"version":3,"mappings":"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","names":["starknetSignReducer","state","action","type","loading","data","error","undefined","useSignTypedData","typedData","dispatch","account","accountAddress","connectors","reset","signTypedData","accountInterface","availableConnectors","filter","conn","available","connector","address","Error","response","signMessage","err","errorMessage","message","String","console","exports"],"sources":["../../src/hooks/sign.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}